@namespace Aspire.Dashboard.Components
@using Aspire.Dashboard.Otlp.Model
@using Aspire.Dashboard.Otlp.Model.MetricValues

<div id="@ChartDivId" style="width:800px; height:400px"></div>

@code {
    // Define the size of the graph based on the number of points and the duration of each point
    private const int GRAPH_POINT_COUNT = 18; // 3 minutes
    private const int GRAPH_POINT_SIZE = 10; // 10s

    private static int LastId = 0;

    private readonly int _instanceID = ++LastId;
    private string ChartDivId => $"lineChart{_instanceID}";

    private double[]? _chartLabels;
    private double[]? _chartValues;

    [Inject]
    public required IJSRuntime JSRuntime { get; set; }

    [Parameter, EditorRequired]
    public required OtlpInstrument Instrument { get; set; }

    [Parameter, EditorRequired]
    public required DimensionScope Dimension { get; set; }

    protected override void OnInitialized()
    {
        _chartLabels = _CalcLabels(GRAPH_POINT_COUNT, GRAPH_POINT_SIZE);
    }

    protected override void OnParametersSet()
    {
        _chartValues = CalcChartValues(Dimension, GRAPH_POINT_COUNT, GRAPH_POINT_SIZE);
        base.OnParametersSet();
    }

    private double[] _CalcLabels(int pointCount, int pointSize)
    {
        var duration = pointSize * pointCount;
        var labels = new double[pointCount];
        for (var i = 0; i < pointCount; i++)
        {
            labels[i] = (pointSize * (i + 1)) - duration;
        }
        return labels;
    }

    // Graph is not based on x,y coordinates, but rather a series of data points with a value
    // Each point in the graph is the max value of all the values in that point's time range
    private double[] CalcChartValues(DimensionScope dimension, int pointCount, int pointSize)
    {
        var duration = pointSize * pointCount;
        var values = new double[pointCount];
        var now = DateTime.UtcNow;
        foreach (var point in dimension.Values)
        {
            var start = CalcOffset(now - point.Start, pointCount, pointSize);
            var end = CalcOffset(now - point.End, pointCount, pointSize);
            if (start is not null && end is not null)
            {
                for (var i = start.GetValueOrDefault(0); i <= end.GetValueOrDefault(pointCount - 1); i++)
                {
                    values[i] = point switch
                    {
                        MetricValue<long> longMetric => Math.Max(longMetric.Value, values[i]),
                        MetricValue<double> doubleMetric => Math.Max(doubleMetric.Value, values[i]),
                        _ => values[i]
                    };
                }
            }
        }
        //Console.WriteLine($"Values: {string.Join(",", values)}");
        return values;
    }

    // Calculate the offset of each metric value in the graph based on the current time
    private int? CalcOffset(TimeSpan difference, int pointCount, int pointSize)
    {

        var offset = (pointCount - 1) - (int)Math.Floor(difference.TotalSeconds / pointSize);
        return (offset >= 0 && offset < pointCount) ? offset : null;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        var data = new[]
        {
            new
            {
                x = _chartLabels,
                y = _chartValues,
                type = "scatter"
            }
        };

        var layout = new
        {
            title = Instrument?.Name ?? "unknown",
            showlegend = false,
            xaxis = new
            {
                title = "Time (s)"
            }
        };
        var options = new { staticPlot = true };

        await JSRuntime.InvokeVoidAsync("Plotly.newPlot", ChartDivId, data, layout, options);
    }

}
