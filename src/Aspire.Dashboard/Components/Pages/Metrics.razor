@page "/Metrics/{applicationInstanceId?}"
@page "/Metrics/{applicationInstanceId}/Meter/{meterName}"
@page "/Metrics/{applicationInstanceId}/Meter/{meterName}/Instrument/{instrumentName}"

@using Aspire.Dashboard.Components.Dialogs
@using Aspire.Dashboard.Model
@using Aspire.Dashboard.Model.Otlp
@using Aspire.Dashboard.Otlp.Model
@using Aspire.Dashboard.Otlp.Storage
@using Microsoft.AspNetCore.Components.Server.ProtectedBrowserStorage
@using Microsoft.Fast.Components.FluentUI
@using System.Web
@inject NavigationManager NavigationManager
@inject IDashboardViewModelService DashboardViewModelService
@inject IJSRuntime JS
@implements IDisposable
@inject ProtectedSessionStorage ProtectedSessionStore

<PageTitle>@DashboardViewModelService.ApplicationName Metrics</PageTitle>

<h1>Metrics</h1>

<div>
    <FluentStack Orientation="Orientation.Vertical">
        <FluentToolbar Orientation="Orientation.Horizontal">
            <FluentSelect TOption="ApplicationViewModel"
                          Items="@_applications"
                          OptionValue="@(c => c.Id)"
                          OptionText="@(c => c.Name)"
                          @bind-SelectedOption="_selectedApplication"
                          @bind-SelectedOption:after="HandleSelectedApplicationChangedAsync" />
            <FluentIcon slot="end" Icon="Icons.Regular.Size20.Clock" Style="margin-right:5px;" />
            <FluentSelect slot="end" TOption="MetricsDurationViewModel"
                          Items="@s_durations"
                          OptionText="@(c => c.Text)"
                          @bind-SelectedOption="_selectedDuration"
                          @bind-SelectedOption:after="HandleSelectedDurationChangedAsync" />
        </FluentToolbar>
        <div class="page-content-area">
            @if (_instruments?.Count > 0)
            {
                <FluentSplitter Style="height:100%" Panel1Size="2fr" Panel2Size="8fr">
                    <Panel1>
                        <FluentTreeView Class="metrics-tree" @bind-CurrentSelected="_selectedTreeItem" @bind-CurrentSelected:after="HandleSelectedTreeItemChanged">
                            <ChildContent>
                                @foreach (var meterGroup in _instruments.GroupBy(i => i.Parent).OrderBy(g => g.Key.MeterName))
                                {
                                    <FluentTreeItem Class="metrics-tree-item" Text="@meterGroup.Key.MeterName" Data="@meterGroup.Key" title="@meterGroup.Key.MeterName" InitiallyExpanded="true" InitiallySelected="@(_selectedInstrument == null && meterGroup.Key == _selectedMeter)">
                                        @foreach (var instrument in meterGroup.OrderBy(i => i.Name))
                                        {
                                            <FluentTreeItem Class="metrics-tree-item" Text="@instrument.Name" Data="@instrument" title="@instrument.Name" InitiallySelected="@(instrument == _selectedInstrument)" />
                                        }
                                    </FluentTreeItem>
                                }
                            </ChildContent>
                        </FluentTreeView>
                    </Panel1>
                    <Panel2>
                        <div class="metrics-content">
                            @if (_selectedInstrument != null)
                            {
                                <ChartContainer Instrument="_selectedInstrument" Dimensions="_selectedInstrument.Dimensions.Values.ToArray()" Duration="_selectedDuration.Duration" />

@*                                 @foreach (var dimension in _selectedInstrument.Dimensions.Values)
                                {
                                    <p><b>Dimension name:</b> @dimension.Name</p>
                                    <p><b>Dimension values count:</b> @dimension.Values.Count()</p>
                                    <table>
                                        <tr>
                                            <th>Start</th>
                                            <th>End</th>
                                            <th>Count</th>
                                            <th>Value</th>
                                        </tr>
                                    @foreach (var item in dimension.Values)
                                    {
                                        <tr>
                                            <td>@item.Start.ToLocalTime()</td>
                                            <td>@item.End.ToLocalTime()</td>
                                            <td>@item.Count</td>
                                            <td>@item.ToString()</td>
                                        </tr>
                                    }
                                    </table>
                                } *@
                            }
                            else if (_selectedMeter != null)
                            {
                                <h3>@_selectedMeter.MeterName</h3>
                                @foreach (var item in _instruments.Where(i => i.Parent == _selectedMeter))
                                {
                                    <p>@item.Name: @item.Description</p>
                                }
                            }
                            else
                            {
                                <p>Select instrument.</p>
                            }
                        </div>
                    </Panel2>
                </FluentSplitter>
            }
            else if (_instruments == null)
            {
                <div class="empty-content">
                    <FluentIcon Icon="Icons.Regular.Size24.ChartMultiple" />&nbsp;Select a service to view metrics
                </div>
            }
            else
            {
                <div class="empty-content">
                    <FluentIcon Icon="Icons.Regular.Size24.ChartMultiple" />&nbsp;No metrics for the selected service
                </div>
            }
        </div>
    </FluentStack>
</div>

@code {
    private static readonly ApplicationViewModel SelectApplication = new ApplicationViewModel { Id = null, Name = "Select service..." };

    private List<ApplicationViewModel> _applications = default!;
    private ApplicationViewModel _selectedApplication = SelectApplication;
    private static readonly List<MetricsDurationViewModel> s_durations = new List<MetricsDurationViewModel>
    {
        new MetricsDurationViewModel { Text = "Last 1 minute", Duration = TimeSpan.FromMinutes(1) },
        new MetricsDurationViewModel { Text = "Last 5 minutes", Duration = TimeSpan.FromMinutes(5) },
        new MetricsDurationViewModel { Text = "Last 15 minutes", Duration = TimeSpan.FromMinutes(15) },
        new MetricsDurationViewModel { Text = "Last 30 minutes", Duration = TimeSpan.FromMinutes(30) },
        new MetricsDurationViewModel { Text = "Last 1 hour", Duration = TimeSpan.FromHours(1) },
        new MetricsDurationViewModel { Text = "Last 3 hours", Duration = TimeSpan.FromHours(3) },
        new MetricsDurationViewModel { Text = "Last 6 hours", Duration = TimeSpan.FromHours(6) },
        new MetricsDurationViewModel { Text = "Last 12 hours", Duration = TimeSpan.FromHours(12) },
        new MetricsDurationViewModel { Text = "Last 24 hours", Duration = TimeSpan.FromHours(24) },
    };
    private MetricsDurationViewModel _selectedDuration = s_durations[0];
    private Subscription? _applicationsSubscription;
    private Subscription? _metricsSubscription;
    private List<OtlpInstrument>? _instruments;
    private FluentTreeItem? _selectedTreeItem;
    private OtlpMeter? _selectedMeter;
    private OtlpInstrument? _selectedInstrument;

    [Parameter]
    public string? ApplicationInstanceId { get; set; }

    [Parameter]
    public string? MeterName { get; set; }

    [Parameter]
    public string? InstrumentName { get; set; }

    [Inject]
    public required TelemetryRepository TelemetryRepository { get; set; }

    [Inject]
    public required TracesViewModel ViewModel { get; set; }

    protected override Task OnInitializedAsync()
    {
        UpdateApplications();
        _applicationsSubscription = TelemetryRepository.OnNewApplications(() => InvokeAsync(() =>
        {
            UpdateApplications();
            StateHasChanged();
        }));
        return Task.CompletedTask;
    }

    protected override void OnParametersSet()
    {
        _selectedApplication = _applications.SingleOrDefault(e => e.Id == ApplicationInstanceId) ?? _applications.ElementAtOrDefault(1) ?? SelectApplication;
        ViewModel.ApplicationServiceId = _selectedApplication.Id;
        _instruments = !string.IsNullOrEmpty(_selectedApplication.Id) ? TelemetryRepository.GetInstruments(_selectedApplication.Id) : null;

        _selectedMeter = null;
        _selectedInstrument = null;
        if (_instruments != null && !string.IsNullOrEmpty(MeterName))
        {
            _selectedMeter = _instruments.FirstOrDefault(i => i.Parent.MeterName == MeterName)?.Parent;
            if (_selectedMeter != null && !string.IsNullOrEmpty(InstrumentName))
            {
                _selectedInstrument = _instruments.FirstOrDefault(i => i.Name == InstrumentName);
            }
        }

        UpdateSubscription();
    }

    private void UpdateApplications()
    {
        _applications = TelemetryRepository.GetApplications().Select(a => new ApplicationViewModel { Id = a.InstanceId, Name = a.ApplicationName }).ToList();
        _applications.Insert(0, SelectApplication);
        UpdateSubscription();
    }

    private Task HandleSelectedApplicationChangedAsync()
    {
        NavigationManager.NavigateTo($"/Metrics/{_selectedApplication.Id}");
        return Task.CompletedTask;
    }

    private Task HandleSelectedDurationChangedAsync()
    {
        return Task.CompletedTask;
    }

    private class MetricsSelectedState
    {
        public const string Key = "Metrics_SelectState";
        public string? ApplicationId { get; set; }
        public string? MeterName { get; set; }
        public string? InstrumentName { get; set; }
    }

    private async Task HandleSelectedTreeItemChanged()
    {
        MetricsSelectedState? state = null;

        if (_selectedTreeItem?.Data is OtlpMeter meter)
        {
            state = new MetricsSelectedState { ApplicationId = _selectedApplication.Id, MeterName = meter.MeterName };
        }
        else if (_selectedTreeItem?.Data is OtlpInstrument instrument)
        {
            state = new MetricsSelectedState { ApplicationId = _selectedApplication.Id, MeterName = instrument.Parent.MeterName, InstrumentName = instrument.Name };
        }

        if (state != null)
        {
            NavigateTo(state);
            await ProtectedSessionStore.SetAsync(MetricsSelectedState.Key, state);
        }
        else
        {
            await ProtectedSessionStore.DeleteAsync(MetricsSelectedState.Key);
        }
    }

    private void NavigateTo(MetricsSelectedState state)
    {
        if (state.MeterName != null)
        {
            if (state.InstrumentName != null)
            {
                NavigationManager.NavigateTo($"/Metrics/{state.ApplicationId}/Meter/{state.MeterName}/Instrument/{state.InstrumentName}");
            }
            else
            {
                NavigationManager.NavigateTo($"/Metrics/{state.ApplicationId}/Meter/{state.MeterName}");
            }
        }
        else
        {
            NavigationManager.NavigateTo($"/Metrics/{state.ApplicationId}");
        }
    }

    private void UpdateSubscription()
    {
        // Subscribe to updates.
        if (_metricsSubscription is null || _metricsSubscription.ApplicationId != _selectedApplication.Id)
        {
            _metricsSubscription?.Dispose();
            _metricsSubscription = TelemetryRepository.OnNewMetrics(_selectedApplication.Id, async () =>
            {
                ViewModel.ClearData();
                await Task.Yield();
                //await InvokeAsync(StateHasChanged);
            });
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            var result = await ProtectedSessionStore.GetAsync<MetricsSelectedState>(MetricsSelectedState.Key);
            if (result.Success && result.Value is not null)
            {
                NavigateTo(result.Value);
            }
        }
    }

    public void Dispose()
    {
        _applicationsSubscription?.Dispose();
        _metricsSubscription?.Dispose();
    }
}
